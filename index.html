<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infegy Topic Analysis Dashboard</title>
    <script src="https://d3js.org/d3.v6.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0 20px 20px 20px;
            background-color: #f9f9f9;
            color: #223354;
        }
        h1, h2, h3 {
            color: #223354;
            margin-bottom: 10px;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
            border-top: 5px solid #22aaff;
            text-align: left;
        }
        .circle-packing {
            margin: 20px 0;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e8eaf2;
        }
        .narrative-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
        }
        .narrative {
            flex: 1 1 calc(50% - 30px);
            min-width: 350px;
            padding: 25px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e8eaf2;
            text-align: left;
            transition: box-shadow 0.3s ease;
            margin-bottom: 30px;
            scroll-margin-top: 100px;
        }
        .narrative h2 {
            font-size: 1.4em;
            font-weight: 600;
            color: #223354;
            margin: 0 0 20px 0;
            letter-spacing: 0.3px;
        }
        .narrative h3 {
            font-size: 1.1em;
            font-weight: 500;
            color: #445566;
            margin: 25px 0 15px 0;
        }
        .key-terms, .personas {
            list-style: none;
            padding: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: flex-start;
        }
        .key-terms li, .personas li {
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-weight: 500;
            font-size: 0.9em;
            transition: all 0.2s ease;
            border: none;
        }
        .key-terms li.positive {
            background: #88dd11;
            color: white;
        }
        .key-terms li.negative {
            background: #ff3366;
            color: white;
        }
        .personas li.male {
            background: #22aaff;
            color: white;
        }
        .personas li.female {
            background: #ee44ee;
            color: white;
        }
        #my_dataviz {
            width: 100%;
            max-width: 800px;
            height: 800px;
            margin: 0 auto;
            overflow: visible;
        }
        .tooltip {
            position: absolute;
            background-color: white;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .narrative:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        .section-header {
            position: relative;
            padding: 15px 0 10px 0;
            margin: 15px 0;
            border-bottom: 2px solid #e8eaf2;
            background: none;
            border-left: none;
        }

        .section-header h2 {
            margin: 0;
            color: #223354;
            font-size: 1.6em;
            font-weight: 600;
            letter-spacing: 0.3px;
        }

        .section-header::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 60px;
            height: 2px;
            background: #22aaff;
        }

        #introduction, #conclusion {
            padding: 0;
            line-height: 1.6;
            font-size: 1.1em;
            color: #445566;
        }

        #introduction p, #conclusion p {
            margin: 15px 0;
        }

        .highlight-text {
            background: none;
            padding: 0;
            border-radius: 0;
            margin: 0 0 30px 0;
            box-shadow: none;
        }

        .narrative-stats {
            display: flex;
            flex-wrap: nowrap;
            justify-content: space-between;
            gap: 10px;
            margin: 0 0 25px 0;
            font-size: 0.9em;
            position: relative;
        }
        .stat-item {
            position: relative;
            padding: 12px 12px;
            border-radius: 8px;
            color: #445566;
            font-weight: 500;
            background: white;
            border: 1px solid #e8eaf2;
            min-width: 120px;
            flex: 1;
            max-width: none;
        }
        .stat-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            border-radius: 4px 0 0 4px;
        }
        .stat-label {
            font-size: 0.85em;
            color: #667788;
            margin-bottom: 4px;
        }
        .stat-value {
            font-size: 1.1em;
            font-weight: 600;
            color: #223354;
        }
        .sentiment-stat::before {
            background: linear-gradient(to bottom, #88dd11, #ff3366);
        }
        .distribution-stat::before {
            background: #22aaff;
        }
        .volume-stat::before {
            background: #22dddd;
        }
        .language-stat::before {
            background: #88dd11;
        }
        .circle-label {
            font-family: 'Roboto', sans-serif;
            font-weight: 500;
            fill: #223354;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            user-select: none;
        }
        .circle-label tspan {
            text-anchor: middle;
        }
        .metadata-stats {
            display: flex;
            justify-content: flex-start;
            gap: 30px;
            margin: 20px 0;
            font-size: 0.95em;
            color: #445566;
        }
        .metadata-item {
            background: none;
            padding: 0;
            border-radius: 0;
            border-left: 2px solid #22aaff;
            padding-left: 15px;
            flex: 0 1 auto;
            box-shadow: none;
        }
        .metadata-label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #223354;
            font-size: 1.1em;
            letter-spacing: 0.3px;
        }
        .metadata-value {
            font-size: 1.05em;
            color: #445566;
            line-height: 1.4;
        }
        .color-legend {
            margin: 15px 0;
            padding: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 40px;
            background: none;
            border: none;
        }
        .legend-section {
            flex: 1;
            min-width: 250px;
            margin: 0;
        }
        .legend-title {
            font-weight: 600;
            color: #223354;
            margin-bottom: 12px;
            font-size: 0.95em;
        }
        .legend-items {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            color: #445566;
            padding: 4px 0;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        .viz-instructions {
            color: #445566;
            font-size: 0.9em;
            text-align: center;
            margin: 15px 0 5px 0;
            line-height: 1.4;
        }
        .viz-instructions strong {
            color: #223354;
        }
        .viz-instructions span {
            display: inline-block;
            margin: 0 8px;
        }
        .app-header {
            background: white;
            padding: 24px 40px;
            border-bottom: 1px solid #e8eaf2;
            margin: 0 -20px 30px -20px;
            display: flex;
            align-items: center;
            min-height: 80px;
        }
        
        .brand-section {
            display: flex;
            align-items: center;
            gap: 28px;
            width: 100%;
            height: 100%;
        }
        
        .logo {
            height: 40px;
            width: auto;
            display: block;
        }
        
        .product-name {
            padding-left: 28px;
            border-left: 1px solid #e8eaf2;
            color: #223354;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            height: 40px;
        }
        
        .demo-badge {
            background: linear-gradient(135deg, #22aaff 0%, #88ccff 100%);
            color: white;
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 0.85em;
            font-weight: 500;
            letter-spacing: 0.3px;
            font-family: 'Inter', sans-serif;
        }

        h1 {
            padding: 0 10px;
            margin-top: 0;
            margin-bottom: 20px;
        }

        .example-posts {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .example-post {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            color: #445566;
            font-size: 0.95em;
            line-height: 1.5;
            border-left: 3px solid #22aaff;
        }

        .example-post:hover {
            background: #f3f4f6;
        }

        .example-post p {
            margin: 0;
        }

        .example-post em {
            color: #223354;
            font-style: normal;
            font-weight: 500;
        }

        .example-post strong {
            color: #223354;
            font-weight: 600;
        }

        .ridgeline-path {
            fill-opacity: 0.6;
            stroke: #fff;
            stroke-width: 0.5;
            cursor: pointer;
            transition: fill-opacity 0.2s;
        }

        .ridgeline-path:hover {
            fill-opacity: 0.8;
        }

        .ridgeline-label {
            font-family: 'Roboto', sans-serif;
            font-size: 12px;
            font-weight: 500;
            fill: #445566;
        }

        .ridgeline-plot {
            margin: 30px 0;
            padding: 20px;
            background: white;
        }

        .highlight-text {
            margin-top: 40px;
        }

        .date-line {
            pointer-events: none;
        }
        .date-label {
            pointer-events: none;
            font-family: 'Roboto', sans-serif;
        }
        .tooltip {
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: white;
            border: 1px solid #e8eaf2;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .viz-title {
            font-size: 1.2em;
            font-weight: 500;
            color: #223354;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e8eaf2;
        }
        .page-layout {
            display: flex;
            gap: 30px;
            position: relative;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .toc-container {
            position: sticky;
            top: 20px;
            height: fit-content;
            min-width: 250px;
            max-width: 250px;
            background: white;
            border-radius: 10px;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-top: 20px;
            overflow-y: auto;
        }

        .toc-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #223354;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e8eaf2;
        }

        .toc-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .toc-item {
            margin-bottom: 10px;
        }

        .toc-link {
            display: block;
            padding: 8px 12px;
            color: #445566;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.9em;
            position: relative;
        }

        .toc-link:hover {
            background: #f8f9fa;
            color: #22aaff;
        }

        .toc-link.active {
            background: #e8f5ff;
            color: #22aaff;
            font-weight: 500;
        }

        .toc-link.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #22aaff;
            border-radius: 0 2px 2px 0;
        }

        .narrative-submenu {
            margin-top: 5px;
            padding-left: 20px !important;
            border-left: 2px solid #e8eaf2;
            list-style: none;
        }

        .toc-link.narrative-link {
            padding-left: 15px;
            font-size: 0.85em;
            color: #445566;
        }

        .toc-link.narrative-link.active {
            background: #e8f5ff;
            color: #22aaff;
            font-weight: 500;
        }

        .toc-link.narrative-link:hover {
            background: #f8f9fa;
            color: #22aaff;
        }

        @media (max-width: 1024px) {
            .narrative-submenu {
                padding-left: 0 !important;
                margin: 10px 0;
            }
            
            .narrative-link {
                padding: 6px 10px;
            }
        }

        .viz-title[style*="margin-top"] {
            margin-top: 20px !important;
        }

        .toggle-icon {
            float: right;
            font-size: 0.8em;
            margin-left: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .nested-submenu {
            transition: all 0.3s ease;
        }

        .nested-link {
            font-size: 0.8em;
            padding: 4px 12px !important;
            color: #667788 !important;
        }

        .nested-viz {
            position: relative;
            width: 100%;
            background: white;
            border-radius: 8px;
            border: 1px solid #e8eaf2;
            padding: 20px;
            margin: 20px 0;
            overflow: visible;
            box-sizing: border-box;
        }

        .nested-viz .tooltip {
            position: absolute;
            background: white;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #e8eaf2;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 0.9em;
            line-height: 1.4;
            z-index: 1000;
            pointer-events: none;
        }

        .nested-viz .tooltip strong {
            color: #223354;
            display: block;
            margin-bottom: 4px;
        }

        .nested-narrative {
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .nested-narrative-details {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .nested-viz circle {
            transition: all 0.3s ease;
        }

        .nested-viz text {
            font-family: 'Roboto', sans-serif;
            font-weight: 500;
            pointer-events: none;
        }

        .node-link {
            fill: none;
            stroke: #e8eaf2;
            stroke-width: 1.5;
            transition: stroke 0.3s ease, stroke-width 0.3s ease;
        }

        .node circle {
            transition: all 0.3s ease;
        }

        .node text {
            pointer-events: none;
            z-index: 2;
        }

        .nested-subtopic-label {
            margin-top: 0 !important;
            margin-bottom: 0 !important;
            opacity: 0;
            transform: translateX(-10px);
            animation: slideIn 0.3s ease forwards;
            padding-left: 20px !important;
            border-left: 2px solid #e8eaf2;
        }

        @keyframes slideIn {
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .nested-subtopic-label .toc-link {
            color: #22aaff !important;
            font-size: 0.8em !important;
            padding-left: 35px !important;
            font-style: normal;
        }

        .nested-subtopic-label .toc-link:hover {
            background: #f8f9fa;
        }

        .nested-subtopic-label .toc-link.active {
            background: #e8f5ff;
        }

        .node {
            pointer-events: all;
        }
    </style>
</head>
<body>
    <header class="app-header">
        <div class="brand-section">
            <img src="https://starscape.infegy.com/img/Infegy_Logo_FullColor.svg" alt="Infegy" class="logo">
            <div class="product-name">Topic Discovery Suite</div>
        </div>
    </header>
    
    <div class="page-layout">
        <nav class="toc-container">
            <div class="toc-title">Contents</div>
            <ul class="toc-list" id="toc"></ul>
        </nav>
        
    <div class="container">
        <h1 id="title"></h1>
            
            <div class="metadata-stats">
                <div class="metadata-item">
                    <div class="metadata-label">Analysis Period</div>
                    <div id="timeRange" class="metadata-value"></div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-label">Sample Size</div>
                    <div id="totalCount" class="metadata-value"></div>
                </div>
            </div>

            <div id="introduction" class="highlight-text"></div>
            
            <div class="section-header" id="overview">
                <h2>Overview and Topic Distribution</h2>
            </div>
        <div class="circle-packing">
                <div class="viz-title">Topic Distribution Overview</div>
                <div class="viz-instructions">
                    <strong>Circle size</strong> represents topic distribution percentage
                    <span>•</span>
                    <strong>Circle color</strong> indicates sentiment (red=negative, blue=neutral, green=positive)
                    <span>•</span>
                    <strong>Click any circle</strong> to jump to its detailed analysis
        </div>
                <div id="my_dataviz"></div>
            </div>

            <div class="section-header">
                <h2>Color Guide</h2>
            </div>      
            <div class="color-legend" style="margin-bottom: 40px;">
                <div class="legend-section" style="min-width: 200px;">
                    <div class="legend-title">Topic Sentiment</div>
                    <div class="legend-items">
                        <div class="legend-item">
                            <span class="legend-color" style="background: #88dd11"></span>
                            Positive
                        </div>
                        <div class="legend-item">
                            <span class="legend-color" style="background: #ff3366"></span>
                            Negative
                        </div>
                    </div>
                </div>
                <div class="legend-section" style="min-width: 200px;">
                    <div class="legend-title">Persona Demographics</div>
                    <div class="legend-items">
                        <div class="legend-item">
                            <span class="legend-color" style="background: #22aaff"></span>
                            Male-Majority Group
                        </div>
                        <div class="legend-item">
                            <span class="legend-color" style="background: #ee44ee"></span>
                            Female-Majority Group
                        </div>
                    </div>
                </div>
            </div>

            <div class="section-header">
                <h2>Narrative Analysis</h2>
            </div>
        <div class="narrative-container" id="narratives"></div>
            
            <div class="section-header">
                <h2>Key Findings</h2>
            </div>
            <div id="conclusion" class="highlight-text"></div>
        </div>
    </div>

    <script>
        const COLORS = {
            primary: '#22aaff',
            lightBlue: '#88ccff',
            green: '#88dd11',
            teal: '#22dddd',
            red: '#ff3366',
            pink: '#ee44ee'
        };

        const CHART_CONFIG = {
            margin: {top: 30, right: 40, bottom: 120, left: 100},
            width: 800,
            height: 400,
            legendItemHeight: 15,
            legendPadding: 10,
            itemsPerRow: 3
        };

        const LANGUAGES = {
            en: 'English',
            es: 'Spanish',
            fr: 'French',
            de: 'German',
            it: 'Italian',
            pt: 'Portuguese',
            ru: 'Russian',
            ja: 'Japanese',
            ko: 'Korean',
            zh: 'Chinese',
            ar: 'Arabic',
            hi: 'Hindi',
            tr: 'Turkish',
            nl: 'Dutch',
            pl: 'Polish',
            vi: 'Vietnamese',
            th: 'Thai',
            id: 'Indonesian'
        };

        const utils = {
            formatDate: (dateString) => {
                const date = new Date(dateString);
                return date.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit'
                });
            },

            formatNumber: (num) => new Intl.NumberFormat('en-US').format(num),

            createElementWithClass: (tag, className) => {
                const element = document.createElement(tag);
                if (className) element.classList.add(className);
                return element;
            },

            getLanguageName: (code) => LANGUAGES[code] || code.toUpperCase(),

            parseMarkdown: (text) => {
                if (!text) return '';
                return text.replace(/\n/g, '<br>')
                          .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                          .replace(/\*(.*?)\*/g, '<em>$1</em>');
            }
        };

        function parseMarkdown(text) {
            if (!text) return '';  // Handle null/undefined text
            return text.replace(/\n/g, '<br>')
                       .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                       .replace(/\*(.*?)\*/g, '<em>$1</em>');
        }

        function createLineGraph(data) {
            const margin = {top: 30, right: 40, bottom: 120, left: 100};
            const width = 800 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;
            
            d3.select("#ridgeline-plot").html("");
            
            const svg = d3.select("#ridgeline-plot")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Prepare the data
            const narratives = data.output.narratives
                .filter(n => n.volume_data && Array.isArray(n.volume_data)) // Only include narratives with valid volume_data
                .map(n => ({
                    ...n,
                    volume_data: n.volume_data.map(d => ({
                        date: new Date(d[0]),
                        value: d[1]
                    }))
                }));

            // Check if we have any valid data to display
            if (!narratives.length || !narratives[0].volume_data.length) {
                console.warn("No valid volume data found for line graph");
                return;
            }
            
            // Create scales
            const x = d3.scaleTime()
                .domain(d3.extent(narratives[0].volume_data, d => d.date))
                .range([0, width]);
            
            const y = d3.scaleLinear()
                .domain([0, d3.max(narratives, n => d3.max(n.volume_data, d => d.value))])
                .range([height, 0]);

            // Add X axis
            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .ticks(7)
                    .tickFormat(d3.timeFormat("%b %d")));

            // Add Y axis
            svg.append("g")
                .call(d3.axisLeft(y)
                    .ticks(5)
                    .tickFormat(d => d3.format(",.0f")(d)));

            // Update Y axis label position
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -margin.left + 20) // Move label further left
                .attr("x", -(height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("fill", "#445566")
                .style("font-size", "12px")
                .text("Post Volume");

            // Create line generator
            const line = d3.line()
                .x(d => x(d.date))
                .y(d => y(d.value))
                .curve(d3.curveMonotoneX);

            // Sort narratives by distribution to match circle packing order
            const sortedNarratives = narratives.sort((a, b) => b.distribution - a.distribution);
            
            // Use the site's color scheme in the same order as circle packing
            const colors = [
                '#22aaff', // Primary blue - for largest distribution
                '#88ccff', // Light blue
                '#88dd11', // Green
                '#22dddd', // Teal
                '#ff3366', // Red
                '#ee44ee'  // Pink
            ];

            // Add the lines with consistent color mapping
            const paths = svg.selectAll(".line")
                .data(sortedNarratives)
                .enter()
                .append("path")
                .attr("class", "line")
                .attr("d", d => line(d.volume_data))
                .style("fill", "none")
                .style("stroke", (d, i) => colors[i % colors.length])
                .style("stroke-width", 2)
                .style("opacity", 0.5)
                .attr("id", d => `line-${d.title.replace(/\s+/g, '-').toLowerCase()}`);

            // Create focus groups with same ordering
            const focusGroups = sortedNarratives.map((narrative, i) => {
                const group = svg.append('g');
                
                // Add the circle that travels along the curve
                const focus = group.append('circle')
                    .style("fill", "white")
                    .attr("stroke", colors[i % colors.length])
                    .attr("stroke-width", 2)
                    .attr('r', 4)
                    .style("opacity", 0);

                // Add the text label that travels along the curve
                const focusText = group.append('text')
                    .style("opacity", 0)
                    .attr("text-anchor", "left")
                    .attr("alignment-baseline", "middle")
                    .style("font-size", "12px")
                    .style("fill", "#445566");

                return { focus, focusText, narrative, color: colors[i % colors.length] };
            });

            // Create a rect for mouse tracking
            const mouseTracker = svg.append('rect')
                .style("fill", "none")
                .style("pointer-events", "all")
                .attr('width', width)
                .attr('height', height)
                .on('mouseover', mouseover)
                .on('mousemove', mousemove)
                .on('mouseout', mouseout);

            function mouseover() {
                focusGroups.forEach(({ focus, focusText }) => {
                    focus.style("opacity", 1);
                    focusText.style("opacity", 1);
                });
            }

            function mousemove(event) {
                const [mouseX] = d3.pointer(event);
                const date = x.invert(mouseX);
                
                // Find the closest point to the mouse for each line
                const closestPoints = focusGroups.map(({ narrative }) => {
                    const bisect = d3.bisector(d => d.date).left;
                    const index = bisect(narrative.volume_data, date);
                    const dataPoint = narrative.volume_data[index];
                    if (!dataPoint) return null;

                    // Calculate distance from mouse to point
                    const xDistance = Math.abs(x(dataPoint.date) - mouseX);
                    const yDistance = Math.abs(y(dataPoint.value) - d3.pointer(event)[1]);
                    const distance = Math.sqrt(xDistance * xDistance + yDistance * yDistance);

                    return { narrative, dataPoint, distance };
                }).filter(Boolean);

                // Find the closest line to the mouse
                const closest = closestPoints.reduce((min, current) => 
                    current.distance < min.distance ? current : min
                );

                // Reset all lines to default state
                paths.style("opacity", 0.2)
                     .style("stroke-width", 2);
                
                // Hide all focus points and labels
                focusGroups.forEach(({ focus, focusText }) => {
                    focus.style("opacity", 0);
                    focusText.style("opacity", 0);
                });

                // Only highlight and show data for the closest line
                const activeFocusGroup = focusGroups.find(group => 
                    group.narrative.title === closest.narrative.title
                );

                if (activeFocusGroup) {
                    const { focus, focusText, color } = activeFocusGroup;
                    const { narrative, dataPoint } = closest;

                    // Highlight the active line
                    d3.select(`#line-${narrative.title.replace(/\s+/g, '-').toLowerCase()}`)
                        .style("opacity", 1)
                        .style("stroke-width", 3);

                    // Show and position the focus point
                    focus
                        .style("opacity", 1)
                        .attr("cx", x(dataPoint.date))
                        .attr("cy", y(dataPoint.value));

                    // Show and position the text label
                    focusText
                        .style("opacity", 1)
                        .html(`${narrative.title}: ${d3.format(",")(dataPoint.value)} posts`)
                        .attr("x", x(dataPoint.date) + 15)
                        .attr("y", y(dataPoint.value) - 10)
                        .style("fill", color);
                }

                // Update date label at the bottom
                const dateLabel = svg.select(".date-label");
                if (dateLabel.empty()) {
                    svg.append("text")
                        .attr("class", "date-label")
                        .attr("text-anchor", "middle")
                        .style("fill", "#445566")
                        .style("font-size", "12px");
                }
                svg.select(".date-label")
                    .attr("x", x(date))
                    .attr("y", height + 20)
                    .text(d3.timeFormat("%B %d, %Y")(date));
            }

            function mouseout() {
                // Reset all lines to default state
                paths.style("opacity", 0.5)
                     .style("stroke-width", 2);

                focusGroups.forEach(({ focus, focusText }) => {
                    focus.style("opacity", 0);
                    focusText.style("opacity", 0);
                });

                // Remove date label
                svg.select(".date-label").text("");
            }

            // Remove the old tooltip and overlay paths
            d3.select("#ridgeline-plot .tooltip").remove();
            svg.selectAll(".overlay-path").remove();
        }

        function getLanguageName(code) {
            const languages = {
                'en': 'English',
                'es': 'Spanish',
                'fr': 'French',
                'de': 'German',
                'it': 'Italian',
                'pt': 'Portuguese',
                'ru': 'Russian',
                'ja': 'Japanese',
                'ko': 'Korean',
                'zh': 'Chinese',
                'ar': 'Arabic',
                'hi': 'Hindi',
                'tr': 'Turkish',
                'nl': 'Dutch',
                'pl': 'Polish',
                'vi': 'Vietnamese',
                'th': 'Thai',
                'id': 'Indonesian'
            };
            return languages[code] || code.toUpperCase();
        }

        class TableOfContents {
            static initialize() {
                const sections = [
                    { id: 'introduction', label: 'Introduction' },
                    { id: 'overview', label: 'Topic Distribution' },
                    { type: 'narratives', label: 'Narratives' },
                    { id: 'conclusion', label: 'Key Findings' }
                ];

                const toc = document.getElementById('toc');
                this.renderSections(toc, sections);
            }

            static renderSections(toc, sections) {
                sections.forEach(section => {
                    const li = document.createElement('li');
                    li.className = 'toc-item';
                    
                    if (section.type === 'narratives') {
                        li.innerHTML = `
                            <a href="#narratives" class="toc-link">
                                ${section.label}
                            </a>
                            <ul class="narrative-submenu"></ul>
                        `;
                    } else {
                        li.innerHTML = `<a href="#${section.id}" class="toc-link">${section.label}</a>`;
                    }
                    toc.appendChild(li);
                });
            }

            static initializeObserver() {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const id = entry.target.getAttribute('id');
                        if (!id) return;

                        // Find the corresponding TOC link
                        const tocLink = document.querySelector(`.toc-link[href="#${id}"]`);
                        if (!tocLink) return;

                        if (entry.isIntersecting) {
                            // Remove active class from all links
                            document.querySelectorAll('.toc-link').forEach(link => {
                                link.classList.remove('active');
                            });
                            
                            // Add active class to the current link
                            tocLink.classList.add('active');

                            // If this is a narrative, also highlight the "Narratives" parent section
                            if (id.startsWith('narrative-')) {
                                const narrativesLink = document.querySelector('.toc-link[href="#narratives"]');
                                if (narrativesLink) {
                                    narrativesLink.classList.add('active');
                                }
                            }
                        }
                    });
                }, { 
                    threshold: [0, 0.25, 0.5, 0.75, 1],
                    rootMargin: '-10% 0px -70% 0px'
                });

                // Update the sections to observe, replacing my_dataviz with overview
                const sections = [
                    document.getElementById('introduction'),
                    document.getElementById('overview'),  // Changed from my_dataviz
                    ...Array.from(document.querySelectorAll('.narrative')),
                    document.getElementById('conclusion')
                ];

                sections.forEach(element => {
                    if (element) {
                        observer.observe(element);
                    }
                });
            }

            static updateNestedLabel(parentId, subTopicTitle) {
                // Remove any existing nested labels first
                document.querySelectorAll('.nested-subtopic-label').forEach(el => el.remove());
                
                // Find the parent narrative link
                const parentLink = document.querySelector(`.toc-link[href="#${parentId}"]`);
                if (!parentLink) return;
                
                // Create and insert the nested label
                const nestedLabel = document.createElement('li');
                nestedLabel.className = 'toc-item nested-subtopic-label';
                nestedLabel.innerHTML = `
                    <a class="toc-link narrative-link active">
                        ${subTopicTitle}
                    </a>
                `;
                
                // Insert after the parent link
                const parentItem = parentLink.closest('.toc-item');
                parentItem.insertAdjacentElement('afterend', nestedLabel);
            }

            static removeNestedLabel() {
                document.querySelectorAll('.nested-subtopic-label').forEach(el => el.remove());
            }
        }

        // Initialize the table of contents first
        TableOfContents.initialize();

        // Then fetch and process the data
        fetch('infegy_summary.json')
            .then(response => response.json())
            .then(jsonData => {
                document.getElementById("title").textContent = jsonData.output.title;
                
                // Format and display metadata
                const formatDate = (dateString) => {
                    const date = new Date(dateString);
                    return date.toLocaleDateString('en-US', {
                        month: 'short',
                        day: 'numeric',
                        year: 'numeric',
                        hour: 'numeric',
                        minute: '2-digit'
                    });
                };
                
                const startDate = formatDate(jsonData.output.min_timestamp);
                const endDate = formatDate(jsonData.output.max_timestamp);
                document.getElementById("timeRange").textContent = `${startDate} → ${endDate}`;
                document.getElementById("totalCount").textContent = 
                    new Intl.NumberFormat('en-US').format(jsonData.output.total_count) + " posts";
                
                // Add introduction and conclusion text
                document.getElementById("introduction").innerHTML = `
                    <div class="section-header">
                        <h2>Introduction</h2>
                    </div>
                    ${parseMarkdown(jsonData.output.introduction)}
                `;
                document.getElementById("conclusion").innerHTML = parseMarkdown(jsonData.output.conclusion);

                // Sort narratives by distribution and limit to top 5
                const sortedNarratives = jsonData.output.narratives
                    .sort((a, b) => b.distribution - a.distribution)
                    .slice(0, 5);

                // Create narratives in the main content
                const narrativesContainer = document.getElementById("narratives");
                narrativesContainer.innerHTML = '';

                // Add a wrapper div for each narrative to help with intersection observation
                sortedNarratives.forEach(narrative => {
                    const narrativeId = `narrative-${narrative.title.replace(/\s+/g, '-').toLowerCase()}`;
                    const narrativeDiv = NarrativeBuilder.createNarrative(narrative);
                    narrativeDiv.id = narrativeId;  // Ensure ID is set
                    narrativeDiv.dataset.section = 'narrative';  // Add data attribute for identification
                    narrativesContainer.appendChild(narrativeDiv);
                });

                // Add narratives to the submenu in the table of contents
                const narrativeSubmenu = document.querySelector('.narrative-submenu');
                if (narrativeSubmenu) {
                    narrativeSubmenu.innerHTML = '';
                    sortedNarratives.forEach(narrative => {
                        const narrativeId = `narrative-${narrative.title.replace(/\s+/g, '-').toLowerCase()}`;
                        const narrativeLi = document.createElement('li');
                        narrativeLi.className = 'toc-item';
                        narrativeLi.innerHTML = `
                            <a href="#${narrativeId}" class="toc-link narrative-link">
                                ${narrative.title}
                            </a>
                        `;
                        narrativeSubmenu.appendChild(narrativeLi);
                    });
                }

                // Initialize the observer after all content is loaded
                TableOfContents.initializeObserver();

                // Modify the dimensions for better spacing
                const width = 800;
                const height = 800;  // Increased height

                // Clear existing visualization
                d3.select("#my_dataviz").html("");

                // Update the SVG container height
                const svg = d3.select("#my_dataviz")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .append("g")
                    .attr("transform", "translate(60,20)");  // Added top margin

                // Modify the createHierarchicalData function to properly handle the "Other" category
                function createHierarchicalData(narratives) {
                    // Sort narratives by distribution
                    const sortedNarratives = narratives.sort((a, b) => b.distribution - a.distribution);
                    
                    // Take top 5 narratives (changed from 4)
                    const topNarratives = sortedNarratives.slice(0, 5);
                    const otherNarratives = sortedNarratives.slice(5);
                    
                    // For each top narrative, take only top 5 nested narratives and combine the rest
                    const processNestedNarratives = (nestedArray) => {
                        if (!nestedArray || !nestedArray.length) return [];
                        
                        const sortedNested = nestedArray.sort((a, b) => b.distribution - a.distribution);
                        const topNested = sortedNested.slice(0, 5).map(n => ({
                            name: n.title,  // Map title to name for leaf nodes
                            distribution: n.distribution,
                            positivity: n.positivity
                        }));
                        
                        const otherNested = sortedNested.slice(5);
                        
                        if (otherNested.length > 0) {
                            const otherNestedDist = otherNested.reduce((sum, n) => sum + n.distribution, 0);
                            const otherNestedPos = otherNested.reduce((sum, n) => sum + n.positivity, 0) / otherNested.length;
                            
                            return [...topNested, {
                                name: "Other Sub-Topics",
                                distribution: otherNestedDist,
                                positivity: otherNestedPos
                            }];
                        }
                        
                        return topNested;
                    };
                    
                    return {
                        name: "Topics",
                        children: topNarratives.map(narrative => ({
                            name: narrative.title,
                            distribution: narrative.distribution,
                            positivity: narrative.positivity,
                            children: processNestedNarratives(narrative.nested_narratives)
                        }))
                    };
                }

                // Create hierarchical data structure with limited narratives
                const hierarchicalData = createHierarchicalData(jsonData.output.narratives);

                // Update cluster layout with adjusted spacing
                const cluster = d3.cluster()
                    .size([height - 100, width - 100])  // Keep the overall size
                    .separation((a, b) => {
                        // Increase separation between leaf nodes
                        if (!a.children && !b.children) return 4;  // Increase this value for more spacing between leaf nodes
                        // Keep default spacing for other nodes
                        return a.parent === b.parent ? 1 : 1;
                    });

                // Create the root hierarchy
                const root = d3.hierarchy(hierarchicalData, d => d.children);
                cluster(root);

                // Move the links selection before the nodes to ensure proper layering
                const links = svg.selectAll('path')
                    .data(root.descendants().slice(1))
                    .join('path')
                    .attr("class", "node-link")
                    .lower()  // This ensures links are drawn below nodes
                    .attr("d", d => {
                        return "M" + d.y + "," + d.x
                            + "C" + (d.parent.y + 50) + "," + d.x
                            + " " + (d.parent.y + 150) + "," + d.parent.x
                            + " " + d.parent.y + "," + d.parent.x;
                    });

                // Create node groups with modified hover effects
                const nodes = svg.selectAll(".node")
                    .data(root.descendants())
                    .join("g")
                    .attr("class", "node")
                    .attr("transform", d => `translate(${d.y},${d.x})`)
                    .on("mouseenter", (event, d) => {
                        // Get specific path from hovered node to root
                        let pathToRoot = [];
                        let current = d;
                        while (current) {
                            pathToRoot.push(current);
                            current = current.parent;
                        }

                        // Highlight only the specific links in the path with a more muted and transparent color
                        links
                            .style("stroke", link => {
                                // Check if this link is part of the path to root
                                return pathToRoot.includes(link) && pathToRoot.includes(link.parent)
                                    ? "#a8c4e3"  // Muted blue
                                    : "#e8eaf2";
                            })
                            .style("stroke-width", link => {
                                return pathToRoot.includes(link) && pathToRoot.includes(link.parent)
                                    ? 2.5 
                                    : 1.5;
                            })
                            .style("opacity", link => {
                                return pathToRoot.includes(link) && pathToRoot.includes(link.parent)
                                    ? 0.6  // Increased transparency from 1.0 to 0.6
                                    : 0.3;  // Increased transparency for non-highlighted paths
                            });

                        // Update circle highlight color to match
                        nodes.selectAll("circle")
                            .style("stroke", node => 
                                pathToRoot.includes(node) 
                                ? "#a8c4e3"  // Muted blue
                                : "#fff")
                            .style("stroke-width", node => 
                                pathToRoot.includes(node) 
                                ? 3 
                                : 2)
                            .style("opacity", node => 
                                pathToRoot.includes(node) 
                                ? 0.9  // Slightly reduced opacity for highlighted nodes
                                : 0.7);

                        // Keep text highlighting as is for legibility
                        nodes.selectAll("text")
                            .style("opacity", node => 
                                pathToRoot.includes(node) 
                                ? 1 
                                : 0.5)
                            .style("font-weight", node => 
                                pathToRoot.includes(node) 
                                ? "600" 
                                : "400");
                    })
                    .on("mouseleave", () => {
                        // Reset all styles
                        links
                            .style("stroke", "#e8eaf2")
                            .style("stroke-width", 1.5)
                            .style("opacity", 1);

                        nodes.selectAll("circle")
                            .style("stroke", "#fff")
                            .style("stroke-width", 2)
                            .style("opacity", 1);

                        nodes.selectAll("text")
                            .style("opacity", 1)
                            .style("font-weight", d => 
                                d.children || d.data.name === "Topics" 
                                ? "600" 
                                : "400");
                    });

                // Update the click handler for the dendrogram circles
                nodes.append("circle")
                    .attr("r", d => {
                        if (d.data.name === "Topics") return 5;
                        if (d.data.name === "Other Topics" || d.data.name === "Other Sub-Topics") {
                            return Math.max(5, Math.min(15, d.data.distribution * 80));
                        }
                        return Math.max(5, Math.min(20, d.data.distribution * 100));
                    })
                    .style("fill", d => {
                        // Use branded colors based on hierarchy level and position
                        if (d.data.name === "Topics") return COLORS.primary;
                        if (d.data.name === "Other Topics" || d.data.name === "Other Sub-Topics") {
                            return COLORS.lightBlue;
                        }
                        // For parent nodes (main narratives)
                        if (d.children) {
                            const colors = [COLORS.primary, COLORS.green, COLORS.teal, COLORS.pink, COLORS.red];
                            return colors[d.depth % colors.length];
                        }
                        // For leaf nodes (sub-narratives)
                        const colors = [COLORS.primary, COLORS.lightBlue, COLORS.green, COLORS.teal, COLORS.pink, COLORS.red];
                        return colors[d.parent.children.indexOf(d) % colors.length];
                    })
                    .attr("stroke", "#fff")
                    .style("stroke-width", 2)
                    .style("cursor", "pointer")
                    .on("click", function(event, d) {
                        if (!d.children) {
                            // Find the parent narrative's ID
                            const parentNarrative = d.parent;
                            if (!parentNarrative) return;
                            
                            const narrativeId = `narrative-${parentNarrative.data.name.replace(/\s+/g, '-').toLowerCase()}`;
                            const narrativeSection = document.getElementById(narrativeId);
                            
                            if (narrativeSection) {
                                // Find specifically the Sub-Topics section within the narrative
                                const subTopicsSection = Array.from(narrativeSection.querySelectorAll('h3'))
                                    .find(h3 => h3.textContent === 'Sub-Topics:');
                                
                                if (subTopicsSection) {
                                    // Scroll to the Sub-Topics section
                                    subTopicsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });

                                    // If this is not "Other Sub-Topics", find and click the corresponding circle
                                    if (d.data.name !== "Other Sub-Topics") {
                                        setTimeout(() => {
                                            // Find the nested visualization and its circles
                                            const nestedViz = narrativeSection.querySelector('.nested-viz');
                                            if (nestedViz) {
                                                const circles = nestedViz.querySelectorAll('circle');
                                                circles.forEach(circle => {
                                                    const circleData = d3.select(circle).datum();
                                                    if (circleData.title === d.data.name) {
                                                        // Reset all circles first
                                                        d3.selectAll(nestedViz.querySelectorAll('circle'))
                                                            .classed("active", false)
                                                            .style("stroke", "white")
                                                            .style("stroke-width", 2)
                                                            .style("fill-opacity", 0.85);
                                                        
                                                        // Activate the matching circle
                                                        d3.select(circle)
                                                            .classed("active", true)
                                                            .style("stroke", "#22aaff")
                                                            .style("stroke-width", 3)
                                                            .style("fill-opacity", 1);
                                                        
                                                        // Show the details
                                                        const detailsContainer = narrativeSection.querySelector('.nested-narrative-details');
                                                        if (detailsContainer) {
                                                            detailsContainer.style.display = "block";
                                                            
                                                            // Get the full parent narrative data from the narrative section
                                                            const parentNarrativeData = narrativeSection.__data__;
                                                            // Add the parent narrative data to the circle data
                                                            circleData.parent_narrative = parentNarrativeData;
                                                            
                                                            detailsContainer.innerHTML = createNestedNarrativeDetails(circleData);
                                                        }

                                                        // Update the table of contents with the subtopic
                                                        TableOfContents.updateNestedLabel(narrativeId, d.data.name);
                                                    }
                                                });
                                            }
                                        }, 500); // Wait for scroll to complete
                                    }
                                }
                            }
                        } else {
                            // For parent nodes, just navigate to the narrative section
                            const narrativeId = `narrative-${d.data.name.replace(/\s+/g, '-').toLowerCase()}`;
                            const narrativeSection = document.getElementById(narrativeId);
                            
                            if (narrativeSection) {
                                narrativeSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                        }
                    });

                // Update the text labels with debugging and improved logic
                nodes.append("text")
                    .each(function(d) {
                        const text = d3.select(this);
                        
                        // Debug log to see what data we're getting
                        console.log('Node data:', {
                            name: d.data.name,
                            isRoot: d.data.name === "Topics",
                            hasChildren: !!d.children,
                            depth: d.depth
                        });
                        
                        // Set font size based on hierarchy level
                        const fontSize = d.data.name === "Topics" ? 14 :
                                        d.children ? 13 : 11;
                        
                        // Position all labels to the left of nodes
                        const xPos = -15;
                        
                        // Get the name, ensuring we have a value
                        const name = d.data.name || "Unnamed Node";
                        
                        text.attr("x", xPos)
                            .attr("y", 0)  // Center vertically
                            .attr("text-anchor", "end")  // Right-justify all text
                            .attr("dominant-baseline", "middle")  // Center vertically
                            .style("font-size", `${fontSize}px`)
                            .style("font-weight", d.children || d.data.name === "Topics" ? "600" : "400")
                            .style("fill", "#445566")
                            .style("font-family", "'Roboto', sans-serif")
                            .text(name);  // Use the name we extracted above
                            
                        // Debug: Add a colored border to see text boundaries
                        text.style("stroke", "none")
                            .style("stroke-width", "1px");
                    });

                // Update the visualization instructions
                const instructions = document.querySelector('.viz-instructions');
                instructions.innerHTML = `
                    <strong>Circle size</strong> represents topic distribution percentage
                    <span>•</span>
                    <strong>Click any circle</strong> to jump to its detailed analysis
                `;

                // Add a note about showing top narratives
                const vizTitle = document.querySelector('.viz-title');
                vizTitle.textContent = 'Topic Distribution Overview (Top 5 Narratives)';

                // Add tooltip div for nested visualizations
                const tooltip = d3.select("body")
                    .append("div")
                    .attr("class", "tooltip")
                    .style("opacity", 0)
                    .style("position", "absolute")
                    .style("pointer-events", "none");
            })
            .catch(error => console.error('Error loading JSON:', error));

        class TopicVisualization {
            constructor(data, container) {
                this.data = data;
                this.container = container;
                this.width = CHART_CONFIG.width - CHART_CONFIG.margin.left - CHART_CONFIG.margin.right;
                this.height = CHART_CONFIG.height - CHART_CONFIG.margin.top - CHART_CONFIG.margin.bottom;
            }

            createSVG() {
                return d3.select(this.container)
                    .append("svg")
                    .attr("width", this.width + CHART_CONFIG.margin.left + CHART_CONFIG.margin.right)
                    .attr("height", this.height + CHART_CONFIG.margin.top + CHART_CONFIG.margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${CHART_CONFIG.margin.left},${CHART_CONFIG.margin.top})`);
            }

            createScales() {
                const x = d3.scaleTime()
                    .domain(d3.extent(this.data[0].volume_data, d => d.date))
                    .range([0, this.width]);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(this.data, n => d3.max(n.volume_data, d => d.value))])
                    .range([this.height, 0]);

                return { x, y };
            }

            // ... Add other visualization methods here
        }

        class NarrativeBuilder {
            static createNarrative(narrative) {
                const narrativeDiv = utils.createElementWithClass('div', 'narrative');
                narrativeDiv.id = `narrative-${narrative.title.replace(/\s+/g, '-').toLowerCase()}`;
                narrativeDiv.__data__ = narrative;
                
                const components = [
                    this.createHeader(narrative),
                    this.createStats(narrative),
                    this.createKeyTerms(narrative),
                    this.createDescription(narrative),
                    narrative.nested_narratives?.length ? this.createNestedVisualization(narrative) : null,
                    this.createExamples(narrative),
                    this.createPersonas(narrative)
                ];

                components.forEach(component => {
                    if (component) narrativeDiv.appendChild(component);
                });

                return narrativeDiv;
            }

            static createHeader(narrative) {
                const header = document.createElement('h2');
                header.textContent = narrative.title;
                return header;
            }

            static createStats(narrative) {
                const totalPosts = narrative.key_terms.reduce((sum, term) => sum + (term.est_total_count || 0), 0);
                
                const stats = [
                    {label: 'Sentiment Score', value: `${(narrative.positivity * 100).toFixed(1)}%`, class: 'sentiment-stat'},
                    {label: 'Topic Distribution', value: `${(narrative.distribution * 100).toFixed(1)}%`, class: 'distribution-stat'},
                    {label: 'Total Posts', value: utils.formatNumber(totalPosts), class: 'volume-stat'},
                    {label: 'Language', value: utils.getLanguageName(narrative.language), class: 'language-stat'}
                ];

                const statsDiv = utils.createElementWithClass('div', 'narrative-stats');
                statsDiv.innerHTML = stats.map(stat => `
                    <div class="stat-item ${stat.class}">
                        <div class="stat-label">${stat.label}</div>
                        <div class="stat-value">${stat.value}</div>
                    </div>
                `).join('');

                return statsDiv;
            }

            static createKeyTerms(narrative) {
                const container = document.createElement('div');
                const heading = document.createElement('h3');
                heading.textContent = 'Key Topics:';
                container.appendChild(heading);

                const ul = utils.createElementWithClass('ul', 'key-terms');
                narrative.key_terms.slice(0, 10).forEach(term => {
                    const li = document.createElement('li');
                    li.textContent = term.label;
                    li.classList.add(term.positivity >= 0.5 ? 'positive' : 'negative');
                    ul.appendChild(li);
                });

                container.appendChild(ul);
                return container;
            }

            static createDescription(narrative) {
                const container = document.createElement('div');
                container.innerHTML = `<p>${utils.parseMarkdown(narrative.description)}</p>`;
                return container;
            }

            static createNestedVisualization(narrative) {
                const container = document.createElement('div');
                container.innerHTML = '<h3>Sub-Topics:</h3>';
                
                // Create viz container first
                const vizContainer = utils.createElementWithClass('div', 'nested-viz');
                container.appendChild(vizContainer);
                
                // Create details container after the visualization
                const detailsContainer = document.createElement('div');
                detailsContainer.className = 'nested-narrative-details';
                detailsContainer.style.display = 'none';
                container.appendChild(detailsContainer);

                // Get narrative ID for table of contents updates
                const narrativeId = `narrative-${narrative.title.replace(/\s+/g, '-').toLowerCase()}`;

                // Filter out very small narratives
                let nestedNarratives = narrative.nested_narratives.filter(d => d.distribution > 0.001);

                // Create SVG after the container is added to the DOM
                requestAnimationFrame(() => {
                    // Get actual container width
                    const containerWidth = vizContainer.clientWidth || 800;
                    const width = Math.max(containerWidth - 40, 400); // Ensure minimum width of 400px
                    const height = 350;

                    const svg = d3.select(vizContainer)
                        .append("svg")
                        .attr("width", width)
                        .attr("height", height)
                        .attr("viewBox", `0 0 ${width} ${height}`);

                    // Color scale for sentiment
                    const color = d3.scaleOrdinal()
                        .range([
                            '#22aaff', // Primary blue
                            '#88ccff', // Light blue
                            '#88dd11', // Green
                            '#22dddd', // Teal
                            '#ff3366', // Red
                            '#ee44ee'  // Pink
                        ]);

                    // Size scale for narratives
                    const size = d3.scaleLinear()
                        .domain([0, d3.max(nestedNarratives, d => d.distribution)])
                        .range([10, 100]);

                    // Create a group for each node (circle + text)
                    const node = svg.append("g")
                        .selectAll("g")
                        .data(nestedNarratives)
                        .join("g");

                    // Add circles to each group with updated click handler
                    const circles = node.append("circle")
                        .attr("r", d => size(d.distribution))
                        .attr("cx", 0)
                        .attr("cy", 0)
                        .style("fill", d => color(d.positivity))
                        .style("fill-opacity", 0.85)
                        .attr("stroke", "white")
                        .style("stroke-width", 2)
                        .style("cursor", "pointer")
                        .on("click", function(event, d) {
                            const circle = d3.select(this);
                            const isActive = circle.classed("active");
                            
                            // Reset all circles
                            d3.selectAll(this.parentNode.parentNode.querySelectorAll('circle'))
                                .classed("active", false)
                                .style("stroke", "white")
                                .style("stroke-width", 2)
                                .style("fill-opacity", 0.85);
                            
                            if (!isActive) {
                                // Add parent narrative reference to the data
                                d.parent_narrative = narrative;
                                
                                // Activate clicked circle
                                circle.classed("active", true)
                                    .style("stroke", "#22aaff")
                                    .style("stroke-width", 3)
                                    .style("fill-opacity", 1);
                                
                                // Show details without scrolling
                                detailsContainer.style.display = "block";
                                detailsContainer.innerHTML = createNestedNarrativeDetails(d);

                                // Update the table of contents with the subtopic
                                TableOfContents.updateNestedLabel(narrativeId, d.title);
                            } else {
                                // Hide details if clicking active circle
                                detailsContainer.style.display = "none";
                                // Remove the nested label
                                TableOfContents.removeNestedLabel();
                            }
                        });

                    // Add text labels with the same wrapping logic as your code
                    const labels = node.append("text")
                        .attr("class", "circle-label")
                        .each(function(d) {
                            const radius = size(d.distribution);
                            const fontSize = Math.max(10, Math.min(14, radius / 4));
                            const lineHeight = fontSize * 1.2;
                            const maxLines = Math.floor((radius * 1.6) / lineHeight);
                            const maxWidth = radius * 1.6;
                            
                            let words = d.title.split(/\s+/);
                            let lines = [];
                            let currentLine = [];
                            let currentWidth = 0;
                            
                            words.forEach(word => {
                                const wordWidth = word.length * (fontSize * 0.6);
                                
                                if (currentWidth + wordWidth < maxWidth) {
                                    currentLine.push(word);
                                    currentWidth += wordWidth + (fontSize * 0.6);
                                } else {
                                    if (currentLine.length > 0) {
                                        lines.push(currentLine.join(' '));
                                    }
                                    currentLine = [word];
                                    currentWidth = wordWidth;
                                }
                            });
                            
                            if (currentLine.length > 0) {
                                lines.push(currentLine.join(' '));
                            }
                            
                            lines = lines.slice(0, maxLines);
                            
                            const totalHeight = lines.length * lineHeight;
                            const startY = -(totalHeight / 2) + (lineHeight / 2);
                            
                            const text = d3.select(this);
                            lines.forEach((line, i) => {
                                text.append("tspan")
                                    .attr("x", 0)
                                    .attr("y", startY + (i * lineHeight))
                                    .style("font-size", `${fontSize}px`)
                                    .text(line);
                            });
                        });

                    // Create force simulation
                    const simulation = d3.forceSimulation()
                        .force("center", d3.forceCenter().x(width / 2).y(height / 2).strength(0.3))
                        .force("charge", d3.forceManyBody().strength(d => -10))
                        .force("gravity", d3.forceManyBody().strength(100))
                        .force("collide", d3.forceCollide()
                            .radius(d => size(d.distribution) + 1)
                            .strength(0.8)
                            .iterations(4))
                        .velocityDecay(0.4)
                        .alphaTarget(0.01)
                        .alphaMin(0.001)
                        .alphaDecay(0.04);

                    // Update positions on tick
                    simulation
                        .nodes(nestedNarratives)
                        .on("tick", function() {
                            node.attr("transform", d => {
                                const r = size(d.distribution);
                                d.x = Math.max(r, Math.min(width - r, d.x));
                                d.y = Math.max(r, Math.min(height - r, d.y));
                                return `translate(${d.x},${d.y})`;
                            });
                        });
                });

                return container;
            }

            static createExamples(narrative) {
                if (!narrative.examples || !narrative.examples.length) {
                    return null;
                }

                const container = document.createElement('div');
                container.innerHTML = '<h3>Example Posts:</h3>';
                
                const examplesList = utils.createElementWithClass('div', 'example-posts');
                const examples = Array.isArray(narrative.examples) ? narrative.examples : [narrative.examples];
                
                examples.forEach(example => {
                    const exampleDiv = utils.createElementWithClass('div', 'example-post');
                    const exampleText = typeof example === 'object' ? example.text || example.content : example;
                    exampleDiv.innerHTML = utils.parseMarkdown(exampleText);
                    examplesList.appendChild(exampleDiv);
                });

                container.appendChild(examplesList);
                return container;
            }

            static createPersonas(narrative) {
                const container = document.createElement('div');
                container.innerHTML = '<h3>Personas:</h3>';
                
                const ul = utils.createElementWithClass('ul', 'personas');
                narrative.personas.slice(0, 10).forEach(persona => {
                    const li = document.createElement('li');
                    li.textContent = persona.title;
                    li.classList.add(persona.gender.m > persona.gender.f ? 'male' : 'female');
                    ul.appendChild(li);
                });

                container.appendChild(ul);
                return container;
            }
        }

        // Add this function before creating the circles
        function createNestedNarrativeDetails(nestedNarrative) {
            // Calculate estimated post count based on parent narrative's total posts
            const parentTotalPosts = nestedNarrative.parent_narrative.key_terms.reduce((sum, term) => 
                sum + (term.est_total_count || 0), 0);
            const estimatedPosts = Math.round(parentTotalPosts * nestedNarrative.distribution);

            return `
                <div class="nested-narrative" style="margin-top: 20px; padding: 20px; border: 1px solid #e8eaf2; border-radius: 8px; background: #ffffff;">
                    <h3 style="color: #223354; margin-bottom: 15px;">${nestedNarrative.title}</h3>
                    
                    <div class="narrative-stats" style="margin-bottom: 20px;">
                        <div class="stat-item sentiment-stat">
                            <div class="stat-label">Sentiment Score</div>
                            <div class="stat-value">${(nestedNarrative.positivity * 100).toFixed(1)}%</div>
                        </div>
                        <div class="stat-item distribution-stat">
                            <div class="stat-label">Topic Distribution</div>
                            <div class="stat-value">${(nestedNarrative.distribution * 100).toFixed(1)}%</div>
                        </div>
                        <div class="stat-item volume-stat">
                            <div class="stat-label">Estimated Posts</div>
                            <div class="stat-value">${utils.formatNumber(estimatedPosts)}</div>
                        </div>
                        <div class="stat-item language-stat">
                            <div class="stat-label">Language</div>
                            <div class="stat-value">${utils.getLanguageName(nestedNarrative.language || 'en')}</div>
                        </div>
                    </div>

                    ${nestedNarrative.key_terms ? `
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: #445566; margin-bottom: 10px;">Key Terms:</h4>
                            <ul class="key-terms">
                                ${nestedNarrative.key_terms.slice(0, 5).map(term => `
                                    <li class="${term.positivity >= 0.5 ? 'positive' : 'negative'}">
                                        ${term.label}
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                    ` : ''}

                    ${nestedNarrative.description ? `
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: #445566; margin-bottom: 10px;">Description:</h4>
                            <p style="color: #445566; line-height: 1.6;">${utils.parseMarkdown(nestedNarrative.description)}</p>
                        </div>
                    ` : ''}

                    ${nestedNarrative.examples?.length ? `
                        <div>
                            <h4 style="color: #445566; margin-bottom: 10px;">Example Posts:</h4>
                            <div class="example-posts">
                                ${nestedNarrative.examples.slice(0, 2).map(example => `
                                    <div class="example-post" style="background: #f3f4f6; border-left: 3px solid #22aaff;">
                                        ${utils.parseMarkdown(typeof example === 'object' ? example.text || example.content : example)}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }
    </script>
</body>
</html>
